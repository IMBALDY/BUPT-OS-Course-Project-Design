# 队长第一周进展报告 (3.24-3.30)

## 完成工作

### 1. 系统架构设计

#### 1.1 整体架构

我设计了一个模块化的操作系统架构，主要包含以下几个核心模块：

- **进程管理模块**：负责进程的创建、终止和状态转换
- **内存管理模块**：管理系统内存资源的分配与回收
- **处理机调度模块**：实现各种CPU调度策略
- **时钟管理模块**：提供时钟中断和时间片管理
- **文件系统模块**：管理文件的存储和访问
- **设备管理模块**：控制和管理外部设备
- **用户界面模块**：提供交互式操作环境

这些模块通过明确定义的接口相互协作，确保系统的可扩展性和可维护性。

#### 1.2 模块接口设计

为确保各模块之间松耦合，我定义了以下接口规范：

```java
// 模块间通用接口示例
public interface ModuleInterface {
    boolean initialize();
    void shutdown();
    String getStatus();
}

// 进程管理对外接口
public interface ProcessManagerInterface extends ModuleInterface {
    int createProcess(ProcessConfig config);
    boolean terminateProcess(int pid);
    ProcessInfo getProcessInfo(int pid);
    List<ProcessInfo> listAllProcesses();
}

// 其他模块接口类似定义...
```

### 2. 进程管理模块基础设计

#### 2.1 进程控制块(PCB)设计

进程控制块是表示进程的核心数据结构，包含以下关键信息：

```java
public class PCB {
    private int pid;                  // 进程标识符
    private ProcessState state;       // 进程状态
    private int priority;             // 进程优先级
    private long programCounter;      // 程序计数器
    private List<Integer> registers;  // 寄存器信息
    private MemoryInfo memoryInfo;    // 内存信息
    private ResourceList resources;   // 资源列表
    private long creationTime;        // 创建时间
    private long cpuTimeUsed;         // CPU使用时间
    
    // 构造函数、getter和setter方法
    // ...
}

// 进程状态枚举
public enum ProcessState {
    NEW,        // 新建
    READY,      // 就绪
    RUNNING,    // 运行
    WAITING,    // 等待/阻塞
    TERMINATED  // 终止
}
```

#### 2.2 基本进程控制原语

已经设计并初步实现了以下进程控制原语：

```java
public class ProcessManager {
    // 创建进程
    public int createProcess(ProcessConfig config) {
        PCB pcb = new PCB();
        // 初始化PCB
        pcb.setPid(generatePID());
        pcb.setState(ProcessState.NEW);
        pcb.setPriority(config.getPriority());
        pcb.setCreationTime(System.currentTimeMillis());
        
        // 分配资源
        // ...
        
        // 将进程设置为就绪状态
        pcb.setState(ProcessState.READY);
        
        // 将进程加入就绪队列
        readyQueue.add(pcb);
        
        return pcb.getPid();
    }
    
    // 终止进程
    public boolean terminateProcess(int pid) {
        PCB pcb = findPCBByPID(pid);
        if (pcb == null) {
            return false;
        }
        
        // 释放资源
        // ...
        
        // 更新进程状态
        pcb.setState(ProcessState.TERMINATED);
        
        // 从相关队列中移除
        removeFromQueues(pcb);
        
        return true;
    }
    
    // 其他辅助方法
    // ...
}
```

### 3. 进程状态转换机制

设计了进程状态转换图和相应的转换逻辑：

```java
public class ProcessStateManager {
    // 进程状态转换：就绪 -> 运行
    public void dispatch(PCB pcb) {
        if (pcb.getState() == ProcessState.READY) {
            pcb.setState(ProcessState.RUNNING);
            // 进行上下文切换
            // ...
        }
    }
    
    // 进程状态转换：运行 -> 就绪（时间片用完）
    public void timeout(PCB pcb) {
        if (pcb.getState() == ProcessState.RUNNING) {
            pcb.setState(ProcessState.READY);
            // 保存上下文
            // ...
            // 将进程重新放入就绪队列
            readyQueue.add(pcb);
        }
    }
    
    // 其他状态转换方法
    // ...
}
```

## 下周计划

1. 完成进程控制原语的详细实现
2. 优化进程状态转换机制
3. 与成员B协作，设计进程同步机制的接口
4. 开始系统集成工作

## 遇到的问题与解决方案

1. **问题**：进程状态转换的并发安全性考虑
   **解决方案**：计划使用Java的并发工具类来确保状态转换的原子性，避免竞态条件

2. **问题**：PCB设计中需要考虑的属性较多，如何保持设计的简洁性
   **解决方案**：将PCB拆分为核心属性和扩展属性两部分，采用组合模式设计

## 参考资料

1. 《操作系统概念》第9章 - 进程管理
2. Java并发编程实践
3. 课程设计需求文档 