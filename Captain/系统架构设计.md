# 操作系统模拟程序系统架构设计

## 1. 总体架构

### 1.1 系统分层结构

本系统采用经典的分层架构设计，从底层到顶层分为：

1. **硬件抽象层**：模拟硬件设备，提供基本操作接口
2. **核心管理层**：包含各个关键管理模块
3. **系统服务层**：提供给上层应用的系统调用接口
4. **用户界面层**：提供用户交互功能

### 1.2 模块组成

系统由以下核心模块组成：

```
操作系统模拟程序
├── 进程管理模块
│   ├── 进程控制块(PCB)管理
│   ├── 进程控制原语
│   ├── 进程状态转换
│   └── 进程同步与通信
├── 内存管理模块
│   ├── 物理内存管理
│   ├── 内存分配与回收
│   └── 页面置换算法
├── 处理机调度模块
│   ├── 短期调度(CPU调度)
│   ├── 调度算法实现
│   └── 上下文切换
├── 时钟管理模块
│   ├── 系统时钟维护
│   ├── 时间片分配
│   └── 定时器服务
├── 文件系统模块
│   ├── 文件控制块管理
│   ├── 目录结构管理
│   ├── 文件操作实现
│   └── 存储空间管理
├── 设备管理模块
│   ├── 设备控制表
│   ├── 设备分配与回收
│   └── I/O调度
└── 用户界面模块
    ├── 图形界面实现
    ├── 系统状态可视化
    └── 用户命令解析
```

### 1.3 系统类图概览

以下是系统核心类的UML类图概览：

```
                  +----------------+
                  | ModuleInterface|
                  +----------------+
                         ▲
                         |
       +----------------+---+----------------+
       |                |   |                |
+-------------+ +-------------+ +-------------+ +--------------+
|ProcessManager| |MemoryManager| |CPUScheduler | |FileSystemMgr|
+-------------+ +-------------+ +-------------+ +--------------+
       ▲                ▲              ▲               ▲
       |                |              |               |
+-------------+ +-------------+ +-------------+ +--------------+
|ProcessMgrImpl| |MemoryMgrImpl| |CPUSchedulerI| |FileSystemImpl|
+-------------+ +-------------+ +-------------+ +--------------+

+------------+      +------------+      +----------------+
|    PCB     |<---->| MemoryBlock|<---->| FileControlBlk |
+------------+      +------------+      +----------------+
      ▲
      |
+------------+
|ProcessStates|
+------------+
```

## 2. 模块交互关系

### 2.1 依赖关系图

```
+----------------+      +-----------------+      +----------------+
| 用户界面模块   | ---> | 系统服务层接口  | <--- | 文件系统模块   |
+----------------+      +-----------------+      +----------------+
                              ^                         ^
                              |                         |
                              v                         v
+-----------------+      +-----------------+      +----------------+
| 进程管理模块    | <--> | 处理机调度模块  | <--> | 设备管理模块   |
+-----------------+      +-----------------+      +----------------+
       ^  ^  ^                   ^                      ^
       |  |  |                   |                      |
       v  |  v                   v                      v
+-----------------+      +-----------------+      +----------------+
| 内存管理模块    | <--- | 时钟管理模块    | <--- | 中断系统       |
+-----------------+      +-----------------+      +----------------+
```

### 2.2 关键交互流程

#### 2.2.1 进程创建流程

1. 用户界面请求创建进程
2. 系统服务层接收请求并调用进程管理模块
3. 进程管理模块创建PCB
4. 内存管理模块分配内存空间
5. 进程被添加到就绪队列
6. 处理机调度模块决定是否立即调度该进程

详细时序图：
```
用户界面     系统服务层     进程管理      内存管理     处理机调度
   |             |            |            |            |
   |--创建请求-->|            |            |            |
   |             |--创建进程->|            |            |
   |             |            |--申请内存->|            |
   |             |            |<-分配内存--|            |
   |             |            |--初始化PCB-|            |
   |             |            |--加入就绪队列---------->|
   |             |            |            |            |--调度决策-|
   |             |            |            |            |<----------|
   |             |<-返回PID---|            |            |
   |<-创建结果---|            |            |            |
```

#### 2.2.2 CPU调度流程

1. 时钟模块产生时钟中断
2. 中断处理程序通知处理机调度模块
3. 处理机调度模块执行调度算法
4. 进程管理模块负责进程状态转换
5. 上下文切换完成，新进程获得CPU

详细时序图：
```
时钟模块     中断系统     处理机调度     进程管理      内存管理
   |            |            |            |            |
   |--时钟中断->|            |            |            |
   |            |--调度通知->|            |            |
   |            |            |--执行调度算法           |
   |            |            |--选择进程->|            |
   |            |            |            |--保存上下文|
   |            |            |            |--状态转换--|
   |            |            |            |--加载上下文|
   |            |            |<-切换完成--|            |
   |            |<-处理完成--|            |            |
   |<-中断返回--|            |            |            |
```

### 2.3 数据流图

#### 2.3.1 进程管理数据流

```
                  +-------------+
                  | 用户交互    |
                  +-------------+
                        |
                        v
   +-------+      +-------------+      +-------+
   | PCB表 |<---->| 进程管理器  |<---->| 内存块 |
   +-------+      +-------------+      +-------+
                        |
      +----------------+v+----------------+
      |                 |                 |
+-------------+  +-------------+  +-------------+
| 就绪队列    |  | 阻塞队列    |  | 运行队列    |
+-------------+  +-------------+  +-------------+
```

#### 2.3.2 内存管理数据流

```
                  +-------------+
                  | 进程管理器  |
                  +-------------+
                        |
                        v
   +-------+      +-------------+      +-------+
   |页表   |<---->| 内存管理器  |<---->|空闲块表|
   +-------+      +-------------+      +-------+
                        |
                        v
                  +-------------+
                  | 物理内存    |
                  +-------------+
```

## 3. 接口设计

### 3.1 模块间通用接口

所有模块都实现以下通用接口：

```java
public interface ModuleInterface {
    // 初始化模块
    boolean initialize();
    
    // 关闭模块
    void shutdown();
    
    // 获取模块状态
    String getStatus();
    
    // 重置模块状态
    void reset();
}
```

### 3.2 模块特定接口

#### 3.2.1 进程管理模块接口

```java
public interface ProcessManagerInterface extends ModuleInterface {
    // 创建新进程
    int createProcess(ProcessConfig config);
    
    // 终止指定进程
    boolean terminateProcess(int pid);
    
    // 阻塞进程
    boolean blockProcess(int pid);
    
    // 唤醒进程
    boolean wakeupProcess(int pid);
    
    // 获取进程信息
    ProcessInfo getProcessInfo(int pid);
    
    // 获取所有进程列表
    List<ProcessInfo> listAllProcesses();
    
    // 进程同步接口
    Semaphore createSemaphore(String name, int initialValue);
    boolean waitSemaphore(String name);
    boolean signalSemaphore(String name);
    
    // 进程通信接口
    boolean sendMessage(int sourcePid, int targetPid, Message message);
    Message receiveMessage(int pid, boolean blocking);
}
```

#### 3.2.2 处理机调度模块接口

```java
public interface CPUSchedulerInterface extends ModuleInterface {
    // 设置调度算法
    void setSchedulingAlgorithm(SchedulingAlgorithm algorithm);
    
    // 执行调度
    PCB schedule();
    
    // 进程时间片用完
    void timeSliceExpired(PCB currentProcess);
    
    // 获取当前运行进程
    PCB getCurrentProcess();
    
    // 调度策略枚举
    enum SchedulingAlgorithm {
        FCFS,        // 先来先服务
        RR,          // 时间片轮转
        PRIORITY,    // 优先级调度
        SJF,         // 短作业优先
        MLFQ         // 多级反馈队列
    }
}
```

#### 3.2.3 内存管理模块接口

```java
public interface MemoryManagerInterface extends ModuleInterface {
    // 分配内存
    MemoryAllocation allocateMemory(int processId, int size);
    
    // 释放内存
    boolean freeMemory(int processId);
    
    // 获取内存使用情况
    MemoryStatus getMemoryStatus();
    
    // 页面置换
    boolean pageReplacement(int processId, int pageNumber);
    
    // 设置内存分配算法
    void setAllocationAlgorithm(AllocationAlgorithm algorithm);
    
    // 分配算法枚举
    enum AllocationAlgorithm {
        FIRST_FIT,    // 首次适应
        BEST_FIT,     // 最佳适应
        WORST_FIT,    // 最坏适应
        NEXT_FIT      // 下次适应
    }
}
```

#### 3.2.4 文件系统模块接口

```java
public interface FileSystemInterface extends ModuleInterface {
    // 创建文件
    boolean createFile(String path, FileType type);
    
    // 打开文件
    FileHandle openFile(String path, FileMode mode);
    
    // 关闭文件
    boolean closeFile(FileHandle handle);
    
    // 读文件
    byte[] readFile(FileHandle handle, int offset, int length);
    
    // 写文件
    boolean writeFile(FileHandle handle, int offset, byte[] data);
    
    // 获取文件信息
    FileInfo getFileInfo(String path);
    
    // 列出目录内容
    List<FileInfo> listDirectory(String path);
}
```

## 4. 设计考量

### 4.1 可扩展性

- 采用接口和抽象类定义模块间交互
- 使用工厂模式创建各种调度算法实现
- 通过配置文件动态加载组件
- 提供插件化机制支持自定义功能扩展

### 4.2 并发安全

- 使用Java并发工具确保关键数据结构线程安全
- 采用读写锁优化并发性能
- 关键操作使用事务性处理
- 实现乐观锁机制处理高并发场景

### 4.3 性能优化

- 使用高效数据结构存储进程和资源信息
- 最小化锁竞争
- 高频操作避免频繁对象创建
- 使用缓存减少重复计算和访问开销

## 5. 包结构设计

```
com.os.simulation
├── core                  // 核心框架
│   ├── config            // 配置管理
│   ├── exception         // 异常定义
│   ├── util              // 工具类
│   └── event             // 事件系统
├── process               // 进程管理
│   ├── model             // 进程相关模型
│   ├── service           // 进程管理服务
│   └── queue             // 进程队列实现
├── memory                // 内存管理
│   ├── model             // 内存相关模型
│   ├── service           // 内存管理服务
│   └── algorithm         // 内存分配算法
├── cpu                   // CPU管理
│   ├── model             // CPU相关模型
│   ├── service           // 调度管理服务
│   └── algorithm         // 调度算法实现
├── filesystem            // 文件系统
│   ├── model             // 文件相关模型
│   ├── service           // 文件系统服务
│   └── storage           // 存储实现
├── device                // 设备管理
│   ├── model             // 设备相关模型
│   ├── service           // 设备管理服务
│   └── driver            // 设备驱动实现
├── interrupt             // 中断系统
│   ├── model             // 中断相关模型
│   └── handler           // 中断处理程序
├── ui                    // 用户界面
│   ├── component         // UI组件
│   ├── controller        // UI控制器
│   ├── view              // 视图定义
│   └── model             // 视图模型
└── api                   // 对外接口定义
    ├── process           // 进程管理接口
    ├── memory            // 内存管理接口
    ├── cpu               // CPU调度接口
    ├── filesystem        // 文件系统接口
    └── device            // 设备管理接口
```

## 6. 部署架构

### 6.1 开发环境部署

```
+---------------+    +---------------+    +---------------+
| 开发工具链    |    | 构建系统      |    | 测试框架      |
| - JDK 8+      |    | - Maven       |    | - JUnit       |
| - IDE         |    | - Gradle      |    | - Mockito     |
+---------------+    +---------------+    +---------------+
           |               |                 |
           v               v                 v
       +-------------------------------------------+
       |             版本控制系统                  |
       |               - Git                       |
       +-------------------------------------------+
                           |
                           v
       +-------------------------------------------+
       |             持续集成系统                  |
       |           - GitHub Actions                |
       +-------------------------------------------+
```

### 6.2 运行时架构

```
+---------------+    +---------------+    +---------------+
| 用户交互层    |    | 数据可视化    |    | 系统监控      |
| - GUI         |    | - 进程图      |    | - 性能指标    |
| - 命令行      |    | - 内存图      |    | - 日志记录    |
+---------------+    +---------------+    +---------------+
           |               |                 |
           v               v                 v
       +-------------------------------------------+
       |            系统服务层                     |
       |        - 系统调用接口                     |
       +-------------------------------------------+
                           |
                           v
+---------------+    +---------------+    +---------------+
| 进程/内存管理 |    | 调度/文件系统 |    | 设备/中断管理 |
| - 核心实现    |    | - 核心实现    |    | - 核心实现    |
+---------------+    +---------------+    +---------------+
           |               |                 |
           v               v                 v
       +-------------------------------------------+
       |            硬件抽象层                     |
       |        - 模拟硬件接口                     |
       +-------------------------------------------+
```

## 7. 开发指南

### 7.1 模块扩展步骤

1. **了解现有接口**：详细研究相关模块的接口定义
2. **创建实现类**：实现相应的接口或继承抽象类
3. **注册新组件**：在配置文件中注册新实现的组件
4. **编写单元测试**：确保新实现符合接口规范
5. **集成测试**：验证与其他模块的交互

### 7.2 添加新调度算法流程

1. 在`SchedulingAlgorithm`枚举中添加新算法类型
2. 创建新的调度算法实现类，继承`AbstractSchedulingAlgorithm`
3. 实现核心方法`selectNextProcess()`
4. 在`SchedulerFactory`中注册新算法
5. 在配置文件中启用新算法

### 7.3 代码规范指南

1. **命名规范**：
   - 类名：使用驼峰命名法，首字母大写
   - 方法名：使用驼峰命名法，首字母小写
   - 常量：全大写，用下划线分隔

2. **代码组织**：
   - 相关功能放在同一个包中
   - 一个类只负责一个职责
   - 保持方法简短，一般不超过50行

3. **注释规范**：
   - 类开头必须有JavaDoc注释
   - 公共方法必须有JavaDoc注释
   - 复杂逻辑需要添加详细注释

4. **异常处理**：
   - 使用自定义异常类表达业务异常
   - 不要捕获异常后不处理
   - 日志记录异常详情

## 8. 后续开发计划

### 8.1 第一阶段开发计划（1-2周）

1. 完成基本框架搭建
2. 实现进程、内存和CPU调度基础功能
3. 开发简单的命令行界面
4. 完成基本单元测试

### 8.2 第二阶段开发计划（3-4周）

1. 实现文件系统和设备管理
2. 完善进程同步和通信
3. 开发图形用户界面
4. 添加系统监控和可视化
5. 进行性能测试和优化

### 8.3 未来扩展方向

1. 实现分布式操作系统模拟
2. 添加更多高级调度算法
3. 实现虚拟内存管理
4. 支持模拟网络功能
5. 开发教学辅助模块 